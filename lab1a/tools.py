from typing import List, Tuple, Callable, Union

import matplotlib.pyplot as plt
import numpy as np


def generate_dataset(
    n_samples: int = 100,
    means: np.ndarray = np.array([[4.0, -2.0], [-2.0, 3.0]]),
    standard_deviations: List[float] = [3.5, 5.0],
    seed: int = 20250122,
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Generates a synthetic dataset with two classes,
    where each class follows a Gaussian-like distribution.

    Parameters:
    ----------
    n_samples : int, optional
        The number of samples to generate per class. Default is 100.
    means : np.ndarray, optional
        A 2D array where each row represents the mean (center) of a class
        in 2D space. Default is np.array([[4.0, -2.0], [-2.0, 3.0]]).
    standard_deviations : List[float], optional
        A list of standard deviations for each class. Each standard deviation
        determines the spread of the points around the corresponding mean.
        Default is [3.5, 5.0].
    seed : int, optional
        Random seed for reproducibility. Default is 20250122.

    Returns:
    -------
    Tuple[np.ndarray, np.ndarray]
        A tuple containing:
        - data: A 2D NumPy array of shape (n_samples * num_classes, 2), where
          each row is a point in 2D space.
        - labels: A 1D NumPy array of shape (n_samples * num_classes,),
          where each element is the class label (0, 1, ...).

    Raises:
    ------
    AssertionError
        If the number of class means does not match the number of standard
        deviations or if `means` is not a 2D array.

    Notes:
    -----
    - The data points for each class are generated by adding Gaussian noise
      to the specified class mean, scaled by the corresponding standard
      deviation.
    - The generated data and labels are shuffled to ensure randomness.
    """

    # Ensure two-dimensionality
    assert means.ndim == 2
    # Ensure same amount of classes
    assert len(means) == len(standard_deviations)

    # Initialise data points and labels
    data = []
    labels = []
    generator = np.random.default_rng(seed=seed)

    for i in range(len(means)):
        # Generate random points with specific mean and standard deviation
        points = generator.random((2, n_samples)) * standard_deviations[i] + means[
            i
        ].reshape(2, 1)
        # Add points to data
        data.append(points)
        # Add same label for the generated points
        labels.append(np.full((n_samples), i, dtype=int))

    # Concatenate all data points and labels
    data = np.hstack(data)
    labels = np.hstack(labels)

    # Shuffle data points and labels with same permutation
    indexes = generator.permutation(n_samples * len(means))
    data = data[:, indexes]
    labels = labels[indexes]

    return data, labels


def plot_decision_boundary(
    weights: np.ndarray, data: np.ndarray, labels: np.ndarray, title: str
):
    """
    Plots a 2D dataset with its corresponding decision boundary.

    Parameters:
    ----------
    weights : np.ndarray
        A 1D NumPy array of shape (3,) or (,3) containing the weights of the decision
        boundary equation: [w1, w2, b], where:
        - w1 and w2 are the coefficients for the features X1 and X2.
        - b is the bias term.
    data : np.ndarray
        A 2D NumPy array of shape (2, n_samples) containing the dataset. Each
        column represents a data point, where the first row contains the X1
        coordinates, and the second row contains the X2 coordinates.
    labels : np.ndarray
        A 1D NumPy array of shape (n_samples,) containing the class labels
        (0 or 1) for each data point.
    title : str
        The title of the plot.

    Returns:
    -------
    None
        This function does not return anything. It displays the plot.

    Notes:
    -----
    - The decision boundary is defined by the equation: `w1 * X1 + w2 * X2 + b = 0`.
      If w2 is 0, a vertical line is plotted at `X1 = -b / w1`.
    - The dataset points are colored based on their labels:
        - "Class A" (label 0) is displayed in blue.
        - "Class B" (label 1) is displayed in orange.
    - The plot includes axes with gridlines for better visualization.
    """
    # Unpack weights (w1, w2, b)
    w1, w2, b = weights

    # Generate X1 values (spanning the range of the dataset)
    x1_range = np.linspace(data[0, :].min() - 1, data[0, :].max() + 1, 100)

    # Calculate x2 values using the decision boundary equation
    if w2 != 0:  # Avoid division by zero
        x2_range = -(w1 * x1_range + b) / w2
    else:
        x2_range = np.full_like(x1_range, -b / w1)  # Vertical line if w2 == 0

    # Plot the data points
    plt.scatter(
        data[0, labels != 1],
        data[1, labels != 1],
        label="Class A",
        alpha=0.7,
        color="blue",
    )
    plt.scatter(
        data[0, labels == 1],
        data[
            1,
            labels == 1,
        ],
        label="Class B",
        alpha=0.7,
        color="orange",
    )

    # Plot the decision boundary
    plt.plot(x1_range, x2_range, "k--", label="Decision boundary")

    # Customize the plot
    plt.axhline(0, color="gray", linestyle="--", linewidth=0.5)
    plt.axvline(0, color="gray", linestyle="--", linewidth=0.5)
    plt.xlabel("X1")
    plt.ylabel("X2")
    plt.legend()
    plt.title(title)
    plt.tight_layout()
    plt.show()


def add_bias(X: np.ndarray) -> np.ndarray:
    """
    Adds a bias term to the input data by appending a row of ones.

    Parameters:
    ----------
    X : np.ndarray
        A 2D NumPy array of shape (n_features, n_samples), where each column
        represents a data point.

    Returns:
    -------
    np.ndarray
        A 2D NumPy array of shape (n_features + 1, n_samples) with an
        additional bias row of ones.
    """
    return np.vstack((X, np.ones((1, X.shape[1]))))


def subsample_random(
    data: np.ndarray, 
    labels: np.ndarray, 
    fraction: float, 
    class_label: Union[int, None] = None, 
    seed: int = 42
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Removes a fraction of the dataset randomly, optionally filtered by class_label.

    Parameters:
        data (np.ndarray): The dataset of shape (features, samples).
        labels (np.ndarray): Labels corresponding to the samples (1D array).
        fraction (float): Fraction of samples to be removed (0 < fraction < 1).
        class_label (Union[int, None]): If specified, only subsamples from this class.
        seed (int): Random seed for reproducibility.

    Returns:
        Tuple[np.ndarray, np.ndarray]: Subsampled data and corresponding labels.
    """
    np.random.seed(seed)

    if class_label is None:
        # Subsample from entire dataset
        total_samples = int(data.shape[1] * fraction)
        indices = np.random.choice(data.shape[1], total_samples, replace=False)
    else:
        # Subsample only from specified class
        class_indices = np.where(labels == class_label)[0]
        total_samples = int(len(class_indices) * fraction)
        indices = np.random.choice(class_indices, total_samples, replace=False)

    # Create new dataset excluding selected indices
    mask = np.ones(data.shape[1], dtype=bool)
    mask[indices] = False
    return data[:, mask], labels[mask]


def subsample_condition(
    data: np.ndarray, 
    labels: np.ndarray, 
    condition_func1: Callable[[np.ndarray], np.ndarray], 
    fraction1: float, 
    condition_func2: Callable[[np.ndarray], np.ndarray], 
    fraction2: float, 
    seed: int = 42
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Removes specified fractions of the dataset based on two condition functions.

    Parameters:
        data (np.ndarray): The dataset of shape (features, samples).
        labels (np.ndarray): Labels corresponding to the samples (1D array).
        condition_func1 (Callable[[np.ndarray], np.ndarray]): Condition function for subset 1 (e.g., X1 < 0).
        fraction1 (float): Fraction of samples to remove from subset 1.
        condition_func2 (Callable[[np.ndarray], np.ndarray]): Condition function for subset 2 (e.g., X1 > 0).
        fraction2 (float): Fraction of samples to remove from subset 2.
        seed (int): Random seed for reproducibility.

    Returns:
        Tuple[np.ndarray, np.ndarray]: Subsampled data and corresponding labels.
    """
    np.random.seed(seed) 

    # Find indices satisfying each condition
    indices_classA = np.where(labels == 0)[0]  # Class A indices
    indices_classB = np.where(labels == 1)[0]  # Class B indices
    indices_subset1 = np.where(condition_func1(data))[0]  # Class A subset 1 (X1 < 0)
    indices_subset2 = np.where(condition_func2(data))[0]  # Class A subset 2 (X1 > 0)

    # Separate indices for Class A and Class B
    classA_indices_to_remove = np.intersect1d(indices_classA, np.concatenate([indices_subset1, indices_subset2]))
    
    # Randomly select indices to remove from Class A subsets
    total_remove_subset1 = int(len(np.intersect1d(indices_classA, indices_subset1)) * fraction1)
    total_remove_subset2 = int(len(np.intersect1d(indices_classA, indices_subset2)) * fraction2)
    remove_indices_subset1 = np.random.choice(np.intersect1d(indices_classA, indices_subset1), total_remove_subset1, replace=False)
    remove_indices_subset2 = np.random.choice(np.intersect1d(indices_classA, indices_subset2), total_remove_subset2, replace=False)

    remove_indices_classA = np.concatenate([remove_indices_subset1, remove_indices_subset2])

    # Combine removed indices of Class A and all indices of Class B (Class B is not removed)
    remove_indices = np.concatenate([remove_indices_classA, indices_classB])

    # Create mask to keep only the remaining data
    mask = np.ones(data.shape[1], dtype=bool)
    mask[remove_indices] = False

    return data[:, mask], labels[mask]


def plot_datasets(
    original_data, original_labels, subsampled_data, subsampled_labels, title
):
    """
    This is for task 3.
    """
    plt.figure(figsize=(6, 6))
    plt.scatter(original_data[0, original_labels == 0], original_data[1, original_labels == 0],
                color='blue', alpha=0.1, label='Class A (Original)')
    plt.scatter(original_data[0, original_labels == 1], original_data[1, original_labels == 1],
                color='orange', alpha=0.1, label='Class B (Original)')
    
    plt.scatter(subsampled_data[0, subsampled_labels == 0], subsampled_data[1, subsampled_labels == 0],
                color='blue', alpha=0.7, label='Class A (Subsampled)', edgecolor='k', s=50)
    plt.scatter(subsampled_data[0, subsampled_labels == 1], subsampled_data[1, subsampled_labels == 1],
                color='orange', alpha=0.7, label='Class B (Subsampled)', edgecolor='k', s=50)
    
    plt.title(title)
    plt.xlabel('X1')
    plt.ylabel('X2')
    plt.legend()
    plt.grid(True)
    plt.show()



class PerceptronClassifier:
    def __init__(self) -> None:
        """
        Initializes the PerceptronClassifier with no weights. The weights
        are initialized during training using the `fit` method.
        """
        self.weights: np.ndarray = None

    def fit(
        self,
        X: np.ndarray,
        y: np.ndarray,
        learn_rate: float = 0.25,
        epochs: int = 10,
        batch: bool = False,
    ) -> None:
        """
        Trains the perceptron model using the provided training data and labels.

        Parameters:
        ----------
        X : np.ndarray
            A 2D NumPy array of shape (n_features, n_samples) containing the
            training data. Each column represents a data point.
        y : np.ndarray
            A 1D or 2D NumPy array of shape (n_samples,) or (n_samples, 1)
            containing the class labels for each data point. For binary classification,
            labels should be 0 or 1.
        learn_rate : float, optional
            The learning rate for weight updates. Default is 0.25.
        epochs : int, optional
            The number of passes over the training data. Default is 10.
        batch : bool, optional
            If True, updates are accumulated over all samples in an epoch before being applied (batch learning).
            If False, weights are updated for each sample individually (online learning). Default is False.

        Returns:
        -------
        None
            Trains the model and updates the `weights` attribute in place.

        Notes:
        -----
        - Weights are initialized randomly in the range [-0.05, 0.05].
        - For binary classification, `weights` will have shape (n_features + 1, 1).
        - For multi-class classification, `weights` will have shape (n_features + 1, n_classes).
        """
        inputs = add_bias(X)
        labels = y = (
            y.reshape(-1, 1) if y.ndim == 1 else y
        )  # Ensure y is (1, n_samples)

        rndg = np.random.default_rng(seed=20250122)
        # Initialise weight randomly with mean 0.05 and standard deviation 0.05
        num_classes = len(np.unique(y))
        self.weights = (
            rndg.random((X.shape[0] + 1, 1 if num_classes == 2 else num_classes)) * 0.1
            - 0.05
        )
        # Prepare delta accumulator in case of batch learning
        accumulator = np.zeros_like(self.weights)

        for _ in range(epochs):
            # Get predictions
            preds = self.predict(X)
            # Compute delta weights
            delta = learn_rate * np.dot(inputs, labels - preds)

            if batch:
                accumulator += delta
            else:
                self.weights += delta

        if batch:
            self.weights += accumulator

    def predict(self, X: np.ndarray) -> np.ndarray:
        """
        Predicts class labels for the given input data.

        Parameters:
        ----------
        X : np.ndarray
            A 2D NumPy array of shape (n_features, n_samples) containing the
            input data. Each column represents a data point.

        Returns:
        -------
        np.ndarray
            A 1D NumPy array of shape (n_samples,) for multi-class classification,
            or a 2D array of shape (n_samples, 1) for binary classification.
            Binary predictions are 0 or 1.

        Notes:
        -----
        - For binary classification, activations are thresholded at 0 to predict labels.
        - For multi-class classification, the predicted label corresponds to the
          index of the maximum activation.
        """
        inputs = add_bias(X)

        # Compute activations
        activations = np.dot(np.transpose(self.weights), inputs)
        # Threshold the activations
        if self.weights.shape[1] == 1:  # Binary classification
            return np.where(activations > 0, 1, 0).reshape((-1, 1))
        return np.argmax(activations, axis=0)  # Multi-class classification


class DeltaRuleClassifier:
    def __init__(self) -> None:
        """
        Initializes the DeltaRuleClassifier with no weights. Weights are initialized
        during training using the `fit` method.
        """
        self.weights = None

    def fit(
        self,
        X: np.ndarray,
        y: np.ndarray,
        learn_rate: float = 0.001,
        epochs: int = 20,
        batch: bool = True,
    ) -> None:
        """
        Trains the classifier on the input data and labels using gradient descent.

        Parameters:
        ----------
        X : np.ndarray
            A 2D NumPy array of shape (n_features, n_samples) containing the training data.
            Each column is a data point.
        y : np.ndarray
            A 1D or 2D NumPy array of shape (n_samples,) or (n_samples, n_classes)
            containing the true labels for each data point. Binary labels should be
            represented as 1 and -1 for binary classification.
        learn_rate : float, optional
            The learning rate for weight updates. Default is 0.001.
        epochs : int, optional
            The number of iterations over the training data. Default is 20.
        batch : bool, optional
            If True, updates are accumulated over all samples before being applied to
            the weights (batch learning). If False, weights are updated for each sample
            individually (online learning). Default is True.

        Returns:
        -------
        None
            The trained weights are stored in the `weights` attribute.

        Notes:
        -----
        - The weights are initialized randomly in the range [-0.05, 0.05].
        - For binary classification, `weights` will have shape (n_features + 1, 1).
        - For multi-class classification, `weights` will have shape
          (n_features + 1, n_classes).
        """
        inputs = add_bias(X)
        labels = y = (
            y.reshape(-1, 1) if y.ndim == 1 else y
        )  # Ensure y is (1, n_samples)

        rndg = np.random.default_rng(seed=20250122)
        # Initialise weight randomly with mean 0.05 and standard deviation 0.05
        num_classes = len(np.unique(y))
        self.weights = (
            rndg.random((X.shape[0] + 1, 1 if num_classes == 2 else num_classes)) * 0.1
            - 0.05
        )
        # Prepare delta accumulator in case of batch learning
        accumulator = np.zeros_like(self.weights)

        for _ in range(epochs):
            # Compute error
            error = labels - np.dot(np.transpose(self.weights), inputs).reshape((-1, 1))
            delta = learn_rate * np.dot(inputs, error)

            if batch:
                accumulator += delta
            else:
                self.weights += delta

        if batch:
            self.weights += delta

    def predict(self, X: np.ndarray) -> np.ndarray:
        """
        Predicts class labels for the input data.

        Parameters:
        ----------
        X : np.ndarray
            A 2D NumPy array of shape (n_features, n_samples) containing the input data.
            Each column is a data point.

        Returns:
        -------
        np.ndarray
            A 2D NumPy array of shape (n_samples, 1) for binary classification,
            containing the predicted labels (1 or -1).
            For multi-class classification, returns a 1D NumPy array of shape (n_samples,)
            containing the predicted class indices (0, 1, ..., n_classes-1).

        Notes:
        -----
        - For binary classification, activations are thresholded at 0.
        - For multi-class classification, the predicted class corresponds to the index
          of the maximum activation for each sample.
        """
        inputs = add_bias(X)

        # Compute activations
        activations = np.dot(np.transpose(self.weights), inputs)
        # Threshold the activations
        if self.weights.shape[1] == 1:  # Binary classification
            return np.where(activations > 0, 1, -1).reshape((-1, 1))
        return np.argmax(activations, axis=0)  # Multi-class classification
